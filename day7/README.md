# 1.定时器（1）

### 使用定时器

定时器（Timer）对于操作系统非常重要。它在原理上却很简单，只是每隔一段时间（比如
0.01秒）就发送一个中断信号给CPU。

假如CPU看不到定时器而仍想计量时间的话，就只能牢记每一条指令的执行时间了。比如，往寄存器写入常数的MOV指令是1个时钟周期（Clock）；加法计算的ADD指令原则上是1个时钟 周期，但根据条件不同可能是2个时钟周期……等等。CPU不仅要牢记这些内容，然后还要据此 调查一下调用这些函数所需的时间，比如，调用这个函数需要150个时钟周期，调用那个函数因 参数不同需要106到587个时钟周期等。 

而这里的“时钟周期”又不是一个固定值。比如CPU主频是100MHz的话，一个时钟周期是10 纳秒；但主频如果是200MHz，1个时钟周期就是5纳秒。既然CPU有各种主频，那么1个时钟 周期的时间也就各不相同

这样做可以勉强通过程序对时间进行管理，实现每隔一定时间进行一次某种处理，比如让钟表（程序）的秒针动起来。如果程序中时间计算出错了，那么做出的钟表不是快就是慢，没法使用

如果没有定时器，还会出现别的麻烦，即不能使用HLT指令。完成这个指令所需的时钟周期，不是个固定值。这样，一旦执行HLT指令，程序就不知道时间了。不能执行HLT指令。

然而实际上，由于有定时器中断，所以不用担心会发生这样的悲剧。程序只需要以自己的步调处理自己的问题就行了。至于到底经过了多长时间，只要在中断处理程序中数一数定时器中断 发生的次数就可以了。就算CPU处于HLT状态，也可以通过中断来唤醒。根本就没必要让程序自 己去记忆时间

所以说定时器非常重要。管理定时器是操作系统的重大任务之一。

要在电脑中管理定时器，只需对PIT进行设定就可以了。PIT是“ Programmable Interval Timer”的缩写，翻译过来就是“可编程的间隔型定时器”。我们可以通过设定PIT，让定时器每隔多少秒 就产生一次中断。因为在电脑中PIT连接着IRQ（interrupt request，参考第6章）的0号，所以只要 设定了PIT就可以设定IRQ0的中断间隔。在旧机种上PIT是作为一个独立的芯片安装在主板 上的，而现在已经和PIC（programmable interrupt controller，参考第6章）一样被集成到别的芯片里了。

如果指定中断周期为0，会被看作是指定为65536。实际的中断产生的频率是单位时间 时钟周期数（即主频）/设定的数值。比如设定值如果是1000，那么中断产生的频率就 是1.19318KHz。设定值是10000的话，中断产生频率就是119.318Hz。再比如设定值是 11932的话，中断产生的频率大约就是100Hz了，即每10ms发生一次中断

我们不清楚其中的详细原理，只知道只要执行3次OUT指令设定就完成了。将中断周期设定为11932的话，中断频率好像就是100Hz，也就是说1秒钟会发生100次中断。那么我们就设定成这 个值吧。把11932换算成十六进制数就是0x2e9c

创建timer.c

讲中断注册到IDT，inlt_gdtidt函数中也要加上几行。这也和键盘处理的时 候差不多

### 计量时间

我们利用定时器来计量时间

新加程序所做的处理是：首先定义了struct TIMERCTL结构体。然后，在结构体内定义了一个计
数变量。初始化PIT时，将这个计数变量设置为0。每次发生定时器中断时，计数变量就以1递增。 也就是说，即使这个计数变量在HariMain中不进行加算， 每1秒钟它也会自动增加100

### 超时功能

现在，从启动开始经过了多少秒这一类问题，我们就可以很轻松地判断了。另外，我们还可以计量处理所花费的时间。具体做法是，处理前看一下时间并把它存放到一个变量里，处理结束 之后再看一下时间，然后只要用减法算出时间差，就能得到答案了

操作系统的定时器经常被用于这样一种情形：“喂，操作系统小兄弟，过了10秒钟以后通知我一声，我要干什么什么”。当然，不一定非要是10秒，也可 以是1秒或30分钟。我们把这样的功能叫做“超时”（timeout）。下面就来实现这个功能吧。

首先往结构体struct TIMERCTL里添加一些代码，以便记录有关超时的信息

``` c
struct TIMERCTL{
	unsigned int count;
	unsigned int timeout;
	struct FIFO8 *fifo;
	unsigned char data;
};
```



以上结构体中的timeout用来记录离超时还有多长时间。一旦这个剩余时间达到0，程序就往FIFO缓冲区里发送数据。定时器就是通过这种方法通知HariMain时间到了

### 设定多个定时器

开发操作系统时，超时功能非常方便，所以在很多地方都可以使用它。比如可以让电子时钟每隔1秒重新显示一次；演奏音乐时，可以用它计量音符的长短；也可以让它以0.1秒1次的频率 来监视没有中断功能的装置。另外，还可以用它实现光标的闪烁功能。 为了简单地实现这些功能，我们要准备很多能够设定超时的定时器

首先把struct TIMERCTL修改成下面这样。

```c 
#define MAX_TIMER	500
struct TIMER{
	unsigned int timeout, flags;
	struct FIFO8 *fifo;
	unsigned char data;
};
struct TIMERCTL{
	unsigned int count;
	struct TIMER timer[MAX_TIMER];	
};
```

加上程序后就能做到多个定时器,出现光标闪烁的效果了

### 加快中断处理(1)

​	现在我们可以自由的使用多个定时器了.从数量上说，已经足够了。但仔细看一下大家会发现，inthandler20还有很大问题：中断处理本来应该在很短的时间内完成，可利用inthandler20时却花费 了很长时间。这就妨碍了其他中断处理的执行，使得操作系统反应很迟钝

​	如果检查inthandler20，能发现每次进行定时器中断处理的时候，都会对所有活动中的定时器
进行“timerctl.timer[i].timeout--;”处理。也就是说，CPU要完成从内存中读取变量值，减去1，然 后又往内存中写入的操作。本来谁也不会注意到这种细微之处，但由于我们想在中断处理程序中 尽可能减少哪怕是一点点工作量，所以才会注意到这里。

我们尝试修改程序

我们改变了程序中变量timer[i].timeout的含义。它指的不再是“所剩时间”，而是“予定时刻”了。因为现在的时刻计数到timerctl.count中去了，所以就拿它和timer[i].timeout进行比较，如果相 同或是超过了，就通过往FIFO缓冲区里传送数据来通知HariMain。大家现在再看一看，我们一直 担心的减法计算没有了。这样一改，程序的速度应该能稍微变快一些了

timer_settime函数中所指定的时间，是“从现在开始多少多少秒以后”的意思，所以用这个时间加上现在的时刻，就可以计算出中断的预定时刻。程序中对这个时刻进行了记录。别的地方 就不用改了

# 2.定时器优化

### 加快中断处理(2)

如果看一下 harib09e的inthandler20，大家会发现每次中断都要执行500次（=MAX_TIMER的次数）if语句，很浪费时间。由于1秒钟就要发生100次中断，这个if语句1秒钟就要执行5万次。 尽管如此，这两个if语句都为真，而其中的flags值得以更改，或者是fifo8_put函数能够执行的频 率，最多也就是每0.5秒1次，即每秒2次左右。其余的49998次if语句都是在做无用功，基本没什么意义

我们来变通一下思考方式，如果是人在进行着这样的定时器管理，会怎么做呢？定时器加在 一起最多有500个。其中有3秒钟以后超时的，有50秒钟以后超时的，也有0.3秒钟以后超时的, 还有一天以后超时的。这种情况下，我们首先会关注哪一个？应该是0.3秒钟以后的那个吧。0.3 秒钟的结束后，下次是3秒钟以后的。也就是没必要把500个都看完，只要看到“下一个”的时刻 就可以了。因此，我们追加一个变量timerctl.next，让它记住下一个时刻。

### 加快中断处理(3)

到了现在，中断处理程序的平均处理时间已经大大缩短了。这真是太好了。可是，现在有一个问题，那就是到达next时刻和没到next时刻的定时器中断，它们的处理时间差别很大。 这样的程序结构不好。因为平常运行一直都很快的程序，会偶尔由于中断处理拖得太长，而搞得 像是主程序要停了似的。更确切一点，这样有时会让人觉得“不知为什么，鼠标偶尔会反应迟钝， 很卡"

因此，我们要让到达next时刻的定时器中断的处理时间再缩短一些。嗯，怎么办呢？模仿sheet.c的做法怎么样呢？我们来试试看。 在sheet.c的结构体struct SHTCTL中，除了sheet0[ ]以外，我们还定义了*sheets[ ]。它里面存放的是按某种顺序排好的图层地址。有了这个变量，按顺序描绘图层就简单了。这次我们在Struct TIMERCTL中也定义一个变量，其中存放按某种顺序排好的定时器地址.

