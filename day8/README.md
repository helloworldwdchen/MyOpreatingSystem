# 1

### 简化字符串显示

当每次要打印字符串时, 程序要先涂上背景色，再在上面写字符，最后完成刷新。既然这部分重复出现，我们就把它归纳到一个函数中，这样更方便使用.

```c
void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l){
	boxfill8(sht->buf, sht->bxsize, b, x, y, x+l*8-1, y+15);
	putfonts8_asc(sht->buf, sht->bxsize, x, y, c, s);
	sheet_refresh(sht, x, y, x+l*8, y+16);
	return ;
}
```

这样主函数里三行就可以变一行了.

### 重新调整FIFO缓冲区

实际上我们并不需要三个定时器缓冲区,一个就够了,这样还可以使代码精简.

# 2

### 测试性能

实际上定时器的性能并没有想像的那么好,每次都会有偏差,如果我们将count改回朴素的++,会发现每次到十秒的值是不一样的,而且在虚拟机上偏差很大.

### 再次调整FIFO缓冲区

既然可以将定时器的缓冲区合并为一个,那也可以让鼠标,键盘和定时器共用一个缓冲区.

我们可以把3个定时器归入1个FIFO缓冲区里。同理，分别将从键盘和鼠标输入的数据也设定为其他值就可以了

``` 
0 ~ 1…………………光标闪烁用定时器 
3…………………3秒定时器 
10…………………10秒定时器 
256 ~ 511…………………键盘输入（从键盘控制器读入的值再加上256）
512 ~ 767……鼠标输入（从键盘控制器读入的值再加上512）
```

这样，1个FIFO缓冲区就可以正常进行处理了

不过现在有一个问题，fifo8_put函数中的参数是char型，所以不能指定767那样的数值,需要改为int型

为此需要修改fifo.c mouse.c keyboard.c .

最后还要修改主函数,这样代码复杂度大大下降,程序的效率也有所提升

### 加快中断处理(4)

现在最费时间的是inthandler20中最后的移位处理和timer_settime中的移位处理. timer_settime虽然不是中断处理程序，但毕竟是在中 断禁止期间进行的，所以必须要迅速完成。如果像现在这样，使用的定时器只有3个，用目前的 处理方式还没什么问题。可当我们面对多任务时，很多应用程序同时运行，每个应用程序都使用 定时器，此时如果还是使用移位处理的话，就有点浪费时间了

具体的方法是使用链式线性表

### 使用哨兵简化程序

